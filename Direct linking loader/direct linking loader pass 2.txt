AIM:
       To write a "C" program to implement Pass two of a direct-linking loader in CS1207 - System Software Lab.

ALGORITHM:

1.Read the header record from object program.
2.Get the CSADDR for the correct control section from ESTAB.
3.Read next input record.
4.If the record type is END, go to step 8.
5.If the record type is ‘T’, place the object code in location which is sum of CSADDR and specified address.
6.If the record type is ‘M’ search the ESTAB for symbol table.
   (i)If found add or subtract symbol value at location CSADDR + specified Address.
   (ii)Otherwise display error message.
7.Read next input record and go to step 4.
8.If end of file is reached,Exit.Otherwise go to step 1.


SOURCE CODE:

#include<stdio.h>
#include<conio.h>
#include<string.h>
#include<stdlib.h>
struct exttable
{
  char csect[20], sname[20];
  int padd,plen;
}estab[20];
struct objectcode
{
 unsigned char code[15];
 int add;
}obcode[500];
void main()
{
 FILE *fp1,*fp2,*fp3;
 int i,j,x,y,pstart,exeloc,start,textloc,loc,textlen,length,location,st,s;
 int n=0,num=0,inc=0,count=0,record=0,mloc[30],mlen[30];
 signed long int newadd;
 char operation,lbl[10],input[10],label[50][10],opr[30],ch,*add1,address[10];
 clrscr();
 fp1=fopen("L2IN.dat","r");
 fp2=fopen("L1OUT.dat","r");
 fp3=fopen("L2OUT.dat","w");
 while(!feof(fp2))
 {
  fscanf(fp2,"%s %s %x %x", estab[num].csect, estab[num].sname, &estab[num].padd, 
                                            &estab[num].plen);
  num++;
 }
 exeloc=estab[0].padd;
 loc=exeloc;
 start=loc;
 st=start;
 while(!feof(fp1))
 {
  fscanf(fp1,"%s",input);
  if(strcmp(input,"H")==0)
  {
   fscanf(fp1,"%s",input);
   for(i=0;i<num;i++)
    if(strcmp(input,estab[i].csect)==0)
    {
     pstart=estab[i].padd;
     break;
    }
   while(strcmp(input,"T")!=0)
    fscanf(fp1,"%s",input);
  }
  do
  {
  if(strcmp(input,"T")==0)
  {
   fscanf(fp1,"%x",&textloc);
   textloc=textloc+pstart;
   for(i=0;i<(textloc-loc);i++)
   {
    strcpy(obcode[inc].code,"..");
    obcode[inc++].add=start++;
   }
   fscanf(fp1,"%x",&textlen);
   loc=textloc+textlen;
  }
  else if(strcmp(input,"M")==0)
  {
   fscanf(fp1,"%x",&mloc[record]);
   mloc[record]=mloc[record]+pstart;
   fscanf(fp1,"%x",&mlen[record]);
   fscanf(fp1,"%s",label[record++]);
  }
  else
  {
   length=strlen(input);
   x=0;
   for(i=0;i<length;i++)
   {
    obcode[inc].code[x++]=input[i];
    if(x>1)
    {
     obcode[inc++].add=start++;
     x=0;
    }
   }
   }
  fscanf(fp1,"%s",input);
 }while(strcmp(input,"E")!=0);
 if(strcmp(input,"E")==0)
   fscanf(fp1,"%s",input);
 }
 for(n=0;n<record;n++)
 {
  operation=label[n][0];
  length=strlen(label[n]);
  for(i=1;i<length;i++)
  {
   lbl[i-1]=label[n][i];
  }
  lbl[length-1]='\0';
  length=0;
  strcpy(address,"\0");
  location=mloc[n]-exeloc;
  loc=location;
  count=0;
  while(length<mlen[n])
  {
   strcat(address,obcode[location++].code);
   count++;
   length+=2;
  }
  for(i=0;i<num;i++)
  {
  if(strcmp(lbl,estab[i].csect)==0)
   break;
  if(strcmp(lbl,estab[i].sname)==0)
   break;
  }
  switch(operation)
  {
   case '+':
    newadd=strtol(address,&add1,16)+(long int)estab[i].padd;
    break;
   case '-':
    newadd=strtol(address,&add1,16)-(long int)estab[i].padd;
    break;
  }
  ltoa(newadd,address,16);
  x=0; y=0;
  while(count>0)
  {
   obcode[loc].code[x++]=address[y++];
   if(x>1)
   {
    x=0; loc++;
    count--;
   }
  }}
 count=0;
 n=0;
 s=st-16;
 fprintf(fp3,"%x\t",s);
 for(i=1;i<=16;i++)
 {
  fprintf(fp3,"xx");
  if(i==4||i==8||i==12)
  {
   fprintf(fp3,"\t");
  }
 }
 fprintf(fp3,"\n\n%x\t",obcode[0].add);
 for(i=0;i<inc;i++)
 {
  fprintf(fp3,"%s",obcode[i].code);
  n++;
  if(n>3)
  {
   fprintf(fp3,"\t");
   n=0;
   count++;
  }
  if(count>3)
  {
   fprintf(fp3,"\n\n%x\t",obcode[i+1].add);
   count=0;
  }}
 fcloseall();
 printf("\n\t***** PASS TWO OF A DIRECT-LINKING LOADER *****\n");
 printf("\nThe contents of the output file (L2OUT.DAT):");
 printf("\n---------------------------------------------------------------");
 printf("\nAddress\t\t\t\tContents");
 printf("\n---------------------------------------------------------------\n");
 fp3=fopen("L2OUT.dat","r");
 ch=fgetc(fp3);
 while(ch!=EOF)
 {
  printf("%c",ch);
  ch=fgetc(fp3);
 }
 fclose(fp3);
 getch();
}

INPUT FILES:

LINK1IN.DAT
H PROGA 000000 000063
D LISTA 000040 ENDA 000054
R LISTB ENDB LISTC ENDC
T 000020 0A 03201D 77100004 050014
T 000054 0F 100014 000008 004051 000004 100000
M 000024 05 +LISTB
M 000054 06 +LISTC
M 000060 06 +LISTB
M 000060 06 -LISTA
E 000020

H PROGB 000000 00007F
D LISTB 000060 ENDB 000070
R LISTA ENDA LISTC ENDC
T 000036 0B 03100000 772027 05100000
T 000070 0F 100000 000008 004051 000004 100060
M 000037 05 +LISTA
M 00003E 05 +ENDA
M 00003E 05 -LISTA
M 000070 06 +ENDA
M 000070 06 -LISTA
M 000070 06 +LISTC
M 00007C 06 +PROGB
M 00007C 06 -LISTA
E 000000

H PROGC 000000 0000051
D LISTC 000030 ENDC 000042
R LISTA ENDA LISTB ENDB
T 000018 0C 03100000 77100004 05100000
T 000042 0F 100030 000008 004051 000004 100000
M 000019 05 +LISTA
M 00001D 05 +LISTB
M 000021 05 +ENDA
M 000021 05 -LISTA
M 000042 06 +ENDA
M 000042 06 -LISTA
M 000042 06 +PROGC
M 00004E 06 +LISTB
M 00004E 06 -LISTA
E 000000

LINK1OUT.DAT

PROGA ** 4000 63
** LISTA 4040
** ENDA 4054
PROGB ** 4063 7F
** LISTB 40C3
** ENDB 40D3
PROGC ** 40E2 51
** LISTC 4112
** ENDC 4124